/* Очередь — это устройство для хранения данных, похожее на стек. Отличие в том, что в стеке последний сохраненный элемент будет первым 
извлеченным, тогда как в очереди первый сохраненный элемент будет первым извлеченным. То есть в стеке используется подход «последний 
вошел — первый вышел» (LJFO), а в очереди используется подход «первый вошел — первый вышел» (FIFO). Очередь похожа на простую оче- 
редь посетителей магазина: первый, кто встал в очередь, будет обслужен первым. Перепишите программу STAKARAY из этой главы, включив в нее класс 
queue вместо класса stack. Кроме того, класс должен иметь два метода: один, называемый put(), для помещения элемента в очередь; и другой, на- 
зываемый get(), для извлечения элемента из очереди. Эти методы эквивалентны методам push() и pop() класса stack. 
Оба класса, stack и queue, используют массив для хранения данных. Однако вместо одного поля top типа int, как в классе stack, вам понадобятся два 
поля для очереди: одна, называемая head, указывающая на начало очереди; и вторая, tail, указывающая на конец очереди. Элементы помещаются 
в конец очереди (как посетители банка, становящиеся в очередь), а извлекаются из начала очереди. Конец очереди перемещается к началу по мас- 
сиву по мере того, как элементы добавляются и извлекаются из очереди. Такие результаты добавляют сложности: если одна из двух переменных 
head или tail примут значение конца массива, то следует вернуться на начало. Таким образом, вам нужно выражение типа 
if(tail == MAX - 1) 
tail = -1; 
для возврата переменной tail и похожее выражение для возврата переменной head. Массив, используемый в очереди, иногда называют круговым 
буфером, так как начало и конец очереди циркулируют по нему вместе с ее данными. */
#include <iostream>
using namespace std;
class queue {
private:
    enum { MAX = 10 }; 
    int q[MAX];        
    int head;          // начало очереди
    int tail;          // конец очереди
    int count;         // количество элементов в очереди
public:
    queue() : head(0), tail(-1), count(0) {} 
    void put(int var) {
        if (count == MAX) {
            cout << "Переполнение очереди";
        }
        tail = (tail + 1) % MAX;
        q[tail] = var;
        ++count;
    }
    int get() {
        if (count == 0) {
            cout << "Очередь пуста";
        }
        int value = q[head];
        head = (head + 1) % MAX;
        --count;
        return value;
    }
};
int main() {
    setlocale(LC_ALL, "rus");
    queue q1;
    int choice, value;
    while (true) {
        cout << "Выберите действие: \n1 - Добавить элемент в очередь\n2 - Извлечь элемент из очереди\n0 - Выйти: ";
        cin >> choice;
        if (choice == 0) {
            break;
        }
        switch (choice) {
        case 1:
            cout << "Введите значение для добавления в очередь: ";
            cin >> value;
            q1.put(value);
            break;
        case 2:
            value = q1.get();
            cout << "Извлеченное значение: " << value << endl;
            break;
        default:
            cout << "Неверный выбор. Пожалуйста, выберите снова." << endl;
        }
    }
    return 0;
}
