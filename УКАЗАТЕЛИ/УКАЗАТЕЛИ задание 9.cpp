/*Допустим, что нам нужно сохранить 100 целых чисел так, чтобы иметь к ним легкий доступ. Допустим, что при этом у нас есть проблема: память 
нашего компьютера так фрагментирована, что может хранить массив, наибольшее количество элементов в котором равно десяти (такие проблемы 
действительно появляются, хотя обычно это происходит с объектами, занимающими большое количество памяти). Вы можете решить эту проблему, 
определив 10 разных массивов по 10 элементов в каждом и массив из 10 указателей на эти массивы. Массивы будут иметь имена a0, a1, a2 и т. д. 
Адрес каждого массива будет сохранен в массиве указателей типа int*, который называется ар. Вы сможете получить доступ к отдельному целому 
используя выражение ap[j][к], где j является номером элемента массива указателей, а к — номером элемента в массиве, на который этот указатель 
указывает. Это похоже на двумерный массив, но в действительности является группой одномерных массивов. Заполните группу массивов тестовыми 
данными (скажем, номерами 0, 10, 20 и т. д.), а затем выведите их, чтобы убедиться, что все работает правильно. */
#include <iostream>
#include <stdlib.h>
using namespace std;

int main() {
	setlocale(LC_ALL, "rus");
	const int kol = 10;
	const int size = 10;
	int* arr[kol];
	for (int i = 0; i < kol; i++) {
		arr[i] = new int[size];
	}
	for (int i = 0; i < kol; i++) {
		for (int j = 0; j < size; j++) {
			arr[i][j] = rand() % 100;
			cout << "A[" << i << "][" << j << "]=" << arr[i][j] << "  ";
		}
		cout << endl;
	}
	int k1, s1;
	cout << "Введите номер массива, который вам необходим (от 0 до 9): "; cin >> k1;
	cout << "Введите порядковый номер элемента массива, который вам необходим (от 0 до 9): "; cin >> s1;
	cout << "arr[" << k1 << "][" << s1 << "]=" << arr[k1][s1];
	for (int i = 0; i < kol; i++)
		delete[] arr[i];
}
