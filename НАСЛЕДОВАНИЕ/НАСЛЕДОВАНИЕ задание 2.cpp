/* Вспомните пример STRCONV из главы 8. Класс String в этом примере имеет дефект: у него нет защиты на тот случай, если его объекты будут инициа- 
лизированы слишком длинной строкой (константа SZ имеет значение 80). Например, определение tring s = "Эта строка имеет очень большую длину и мы 
можем быть уверены, что она не уместится в отведенный буфер, что приведет к непредсказуемым последствиям."; будет причиной переполнения массива 
str строкой s с непредсказуемыми последствиями вплоть до краха системы. Создадим класс Pstring, производный от класса String, в котором предот- 
вратим возможность переполнения буфера при определении слишком длинной строковой константы. Новый конструктор производного класса будет копировать 
в str только SZ-1 символов, если строка окажется слишком длинной, и будет копировать строку полностью, если она будет иметь длину меньшую, чем SZ. 
Напишите функцию main() программы для проверки ее работы со строками разной длины.*/
#include <iostream>
#include <cstring>
#include <Windows.h>
using namespace std;

class String {
protected:
    enum { SZ = 80 };
    char str[SZ];   
public:
    String() {
        str[0] = '\0'; 
    }
    String(const char s[]) {
        strcpy_s(str, s);
    }
    void display() const {
        cout << str;
    }
    operator char* () {
        return str; 
    }
};

class Pstring : public String {
public:
    Pstring(const char s[]);
};

Pstring::Pstring(const char s[]) {
    if (strlen(s) >= SZ) {
        strncpy_s(str, s, SZ - 1); 
        str[SZ - 1] = '\0'; 
    }
    else {
        strcpy_s(str, s); 
    }
}

int main() {
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

    Pstring s1 = "Это очень-очень длинная строка, которая, возможно, да, нет, точно, -- превысит размер, ограниченный SZ.";
    cout << "\ns1 = "; s1.display();

    Pstring s2 = "А это коротенькая строка.";
    cout << "\ns2 = "; s2.display();

    cout << endl;
    return 0;
}
